# -*- coding: utf-8 -*-
"""TK12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13CbDjMEhJ0TGiY5BzFAcJtBKgP2IJROq
"""

!sudo apt update
!sudo apt install libcairo2-dev ffmpeg \
    texlive texlive-latex-extra texlive-fonts-extra \
    texlive-latex-recommended texlive-science \
    tipa libpango1.0-dev
!pip install manim
!pip install IPython --upgrade
!pip install Pillow==9.1

from manim import *

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh -v WARNING Bingo14
# 
# class Bingo14(Scene):
#   def construct(self):
#         # Intro Slide
#         titleText = Text("""
#             Mustang Math Tournament 2022:
#             Bingo #14
#         """)
#         descriptionText = Text("""
#         18. The square with vertices (0,0), (6,0), (6,6), and (0.6) is drawn on the coordinate plane. \n
#         Justin constructs a convex quadrilateral by selecting a non-corner lattice point \n
#         uniformly at random from each side of the square as its vertices. \n
#         If the probability that the area formed by the quadrilateral is \n
#         exactly half the area of the square can be expressed as a reduced common fraction a/b, compute a+b.
#         """, font_size=18)
#         # mustangMathLogo = ImageMobject(os.path.join(
#         #     os.path.dirname(__file__), 'logo.png')).next_to(titleText, UP)
# 
#         self.play(Write(
#             titleText))
#         self.wait(1.5)
#         self.play(FadeOut(titleText), FadeIn(
#             descriptionText))
#         self.wait(26)
#         self.play(FadeOut(descriptionText))
#         # Diagram
#         ax = Axes(
#             x_range=[0, 7, 1],
#             y_range=[0, 7, 1],
#             x_length = 5,
#             y_length = 5)
#         ax_c = ax.add_coordinates()
# 
#         # a dot with respect to the axes
#         self.add(ax_c)
#         rect_points = [[0, 0], [0, 6], [6, 6], [6, 0]]
#         rect = Polygon(*[ax_c.coords_to_point(i, j) for i,j in rect_points])
#         # rect = Rectangle(width=6.0, height=6.0,)
#         self.play(Create(rect, run_time=1.5))
#         top = [Dot(ax_c.coords_to_point(i, 6)) for i in range(1,6)]
#         left = [Dot(ax_c.coords_to_point(0, i)) for i in range(1,6)]
#         right = [Dot(ax_c.coords_to_point(6, i)) for i in range(5,0,-1)]
#         bottom = [Dot(ax_c.coords_to_point(i, 0)) for i in range(5,0,-1)]
#         points = left+top+right+bottom
#         for dot in points:
#           self.play(Create(dot, run_time=0.1))
#         
#         rect_1 = Polygon(*[ax_c.coords_to_point(i, j, 0) for i,j in rect_points],fill_opacity=1, fill_color=BLUE)
#         self.play(Write(rect_1, run_time=0.7))
#         self.bring_to_back(rect_1)
#         self.wait(1)
#         self.remove(rect_1)
#         quad1 = Polygon(*[side[idx-1].get_center() for side,idx in [(top,1), (left,2), (bottom, 1), (right, 3)]], fill_opacity=1, fill_color=RED)
#         self.play(Write(quad1, run_time=1))
#         self.wait(1)
#         self.remove(quad1)
#         self.play(FadeOut(quad1), run_time=1)
#         quad2 = Polygon(*[side[idx-1].get_center() for side,idx in [(top,2), (left,3), (bottom, 4), (right, 1)]], fill_opacity=1, fill_color=GREEN)
#         self.play(Write(quad2, run_time=1))
#         self.wait(1)
#         self.play(FadeOut(quad2), run_time=1)
#         quad3 = Polygon(*[side[idx-1].get_center() for side,idx in [(top,4), (left,1), (bottom, 2), (right, 2)]], fill_opacity=1, fill_color=ORANGE)
#         self.play(Write(quad3, run_time=1))
#         self.wait(1)
#         self.play(FadeOut(quad3), run_time=1)
#         quad4 = Polygon(*[side[idx-1].get_center() for side,idx in [(top,3), (left,4), (bottom, 3), (right, 4)]], fill_opacity=1, fill_color=YELLOW)
#         self.play(Write(quad4, run_time=1))
#         self.wait(1)
#         self.play(FadeOut(quad4), run_time=1)
#         self.wait(0.5)
#         self.play(FadeOut(*points))
#         self.wait(1)
# 
#         quad = Polygon(*[ax_c.coords_to_point(i,j) for i,j in [(1,0), (0,4), (1,6), (6,2)]])
#         self.play(Create(quad, run_time=1))
#         self.wait(0.5)
#         c = Cutout(rect_1, quad, fill_opacity=1, color=BLUE)
#         self.play(Write(c), run_time=1.2)
#         self.play(FadeOut(c), FadeOut(quad),run_time= 1)
#         self.wait(1)
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
#         quad2_points = [(2,0), (0,4), (3,6), (6,3)]
#         quad2 = Polygon(*[ax_c.coords_to_point(i,j) for i,j in quad2_points])
#         self.play(Create(quad2, run_time=1))
#         self.wait(2)
#         c = Cutout(rect_1, quad2, fill_opacity=1, color=BLUE)
# 
#         line_coordinates = [(2,4), (3,4), (3,3),(2,3) ]
# 
#         lines = []
#         for i,j in line_coordinates:
#           for a,b in quad2_points:
#             if i==a or j==b: #if the two points have the same x or y
#               lines.append(Line(ax_c.coords_to_point(i,j), ax_c.coords_to_point(a,b), stroke_color=BLUE))
#         self.play(FadeIn(*lines), run_time=1)
#         center_square = Polygon(*[ax_c.coords_to_point(i,j) for i,j in line_coordinates], fill_opacity=1, fill_color=PINK)
#         self.play(FadeIn(center_square), run_time=1)
# 
#         texts = []
#         
#         padding = [(-1, -1, 3, 0), (-1.5, 1, 0, -3), (-1.5, 1, 3, 0), (1, 1.5, 0, -3)]
#         for idx, alpha in enumerate("abcd"):
#           texts.append(Text(alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0], quad2_points[idx][1]+padding[idx][1])))
#           texts.append(Text("6 - " + alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0] + padding[idx][2], quad2_points[idx][1]+padding[idx][1]+ padding[idx][3])))
#         self.play(FadeIn(*texts), run_time=1)
#         quad_rects = []
#         
#         colors = [GREEN, ORANGE, RED, YELLOW]
#         for a,b, i in zip(rect_points, line_coordinates, [0,1,2,3]):
#           quad_rects.append(Polygon(*[ax_c.coords_to_point(i,j) for i,j in [(a[0], a[1]), (a[0], b[1]), (b[0], b[1]), (b[0], a[1])]], fill_opacity=1, fill_color=colors[i]))
#         self.play(FadeOut(center_square), FadeIn(*quad_rects), run_time=1.5)
# 
#         self.wait(2)
#         self.play(FadeIn(center_square), FadeOut(*quad_rects), FadeOut(*quad2), FadeOut(*lines), FadeOut(*texts), run_time=1)
# 
# 
# 
# 
# 
# 
# 
#         quad2_points = [(3,0), (0,3), (2,6), (6,4)]
#         quad2 = Polygon(*[ax_c.coords_to_point(i,j) for i,j in quad2_points])
#         self.play(Create(quad2, run_time=1))
#         self.wait(2)
#         c = Cutout(rect_1, quad2, fill_opacity=1, color=BLUE)
# 
#         line_coordinates = [(3,3), (2,3), (2,4),(3,4) ]
# 
#         lines = []
#         for i,j in line_coordinates:
#           for a,b in quad2_points:
#             if i==a or j==b: #if the two points have the same x or y
#               lines.append(Line(ax_c.coords_to_point(i,j), ax_c.coords_to_point(a,b), stroke_color=BLUE))
#         self.play(FadeIn(*lines), run_time=1)
# 
#         texts = []
#         
#         padding = [(-1.5, -1, 3, 0), (-1.5, 1.5, 0, -3), (-0.5, 1, 3, 0), (1, 0.5, 0, -3)]
#         for idx, alpha in enumerate("abcd"):
#           texts.append(Text(alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0], quad2_points[idx][1]+padding[idx][1])))
#           texts.append(Text("6 - " + alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0] + padding[idx][2], quad2_points[idx][1]+padding[idx][1]+ padding[idx][3])))
#         self.play(FadeIn(*texts), run_time=1)
#         quad_rects = []
#         
#         colors = [GREEN, ORANGE, RED, YELLOW]
#         for a,b, i in zip(rect_points, line_coordinates, [0,1,2,3]):
#           quad_rects.append(Polygon(*[ax_c.coords_to_point(i,j) for i,j in [(a[0], a[1]), (a[0], b[1]), (b[0], b[1]), (b[0], a[1])]], fill_opacity=1, fill_color=colors[i]))
#         self.play(FadeOut(center_square), FadeIn(*quad_rects), run_time=1.5)
#         self.wait(2)
#         self.play(FadeOut(*quad_rects), FadeOut(*quad2), FadeOut(*lines), FadeOut(*texts), run_time=1)
# 
# 
# 
# 
#         quad2_points = [(4,0), (0,3), (3,6), (6,4)]
#         quad2 = Polygon(*[ax_c.coords_to_point(i,j) for i,j in quad2_points])
#         self.play(Create(quad2, run_time=1))
#         self.wait(2)
#         c = Cutout(rect_1, quad2, fill_opacity=1, color=BLUE)
# 
#         line_coordinates = [(4,3), (3,3), (3,4),(4,4) ]
# 
#         lines = []
#         for i,j in line_coordinates:
#           for a,b in quad2_points:
#             if i==a or j==b: #if the two points have the same x or y
#               lines.append(Line(ax_c.coords_to_point(i,j), ax_c.coords_to_point(a,b), stroke_color=BLUE))
#         self.play(FadeIn(*lines), run_time=1)
#         center_square = Polygon(*[ax_c.coords_to_point(i,j) for i,j in line_coordinates], fill_opacity=1, fill_color=GREEN)
#         self.play(FadeIn(center_square), run_time=1)
# 
#         texts = []
#         
#         padding = [(-2, -1, 3, 0), (-1.5, 1.5, 0, -3), (-1.5, 1, 3, 0), (1, 1, 0, -3)]
#         for idx, alpha in enumerate("abcd"):
#           texts.append(Text(alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0], quad2_points[idx][1]+padding[idx][1])))
#           texts.append(Text("6 - " + alpha, font_size=24, color=RED).move_to(ax_c.coords_to_point(quad2_points[idx][0]+padding[idx][0] + padding[idx][2], quad2_points[idx][1]+padding[idx][1]+ padding[idx][3])))
#         self.play(FadeIn(*texts), run_time=1)
#         quad_rects = []
#         
#         colors = [GREEN, ORANGE, RED, YELLOW]
#         for a,b, i in zip(rect_points, line_coordinates, [0,1,2,3]):
#           quad_rects.append(Polygon(*[ax_c.coords_to_point(i,j) for i,j in [(a[0], a[1]), (a[0], b[1]), (b[0], b[1]), (b[0], a[1])]], fill_opacity=1, fill_color=colors[i]))
#         self.play(FadeOut(center_square), FadeIn(*quad_rects),  run_time=1.5)
#         self.wait(2)
#         self.play(FadeOut(*quad_rects), FadeOut(*quad2),  FadeOut(*lines), FadeOut(*texts), run_time=1)
# 
# 
# 
# 
# 
# 
# 
# 
# 
#         quad2_points = [(3,0), (0,5), (3,6), (6,1)]
#         pb = Dot(ax_c.coords_to_point(3,0))
#         pl = Dot(ax_c.coords_to_point(0,5))
#         pt = Dot(ax_c.coords_to_point(3,6))
#         pr = Dot(ax_c.coords_to_point(6,1))
#         quad2 = Polygon(*[[i.get_x(), i.get_y(), 0] for i in [pb,pl,pt,pr]], fill_opacity=1, fill_color=GREEN)
#         self.play(Create(quad2, run_time=1))
#         self.wait(2)
#         quad2.add_updater(lambda x: x.become(Polygon(*[[i.get_x(), i.get_y(), 0] for i in [pb,pl,pt,pr]], fill_opacity=1, fill_color=GREEN)))
#         l1 = Line(*[Dot(ax_c.coords_to_point(i,j)) for i,j in [[0, 5], [0, 1]]])
#         l2 = Line(*[Dot(ax_c.coords_to_point(i,j)) for i,j in [[6, 1], [6, 5]]])
#         self.play(MoveAlongPath(pl, l1), MoveAlongPath(pr, l2), rate_func=linear)
#         self.wait(1)
#         self.play(FadeOut(quad2, run_time=1), FadeOut(pl, run_time=1),FadeOut(pr, run_time=1))
# 
#         pb = Dot(ax_c.coords_to_point(5,0))
#         pl = Dot(ax_c.coords_to_point(0,3))
#         pt = Dot(ax_c.coords_to_point(1,6))
#         pr = Dot(ax_c.coords_to_point(6,3))
# 
#         quad2 = Polygon(*[[i.get_x(), i.get_y(), 0] for i in [pb,pl,pt,pr]], fill_opacity=1, fill_color=GREEN)
#         self.play(FadeIn(quad2, run_time=1))
#         self.wait(2)
#         quad2.add_updater(lambda x: x.become(Polygon(*[[i.get_x(), i.get_y(), 0] for i in [pb,pl,pt,pr]], fill_opacity=1, fill_color=GREEN)))
#         l3 = Line(*[Dot(ax_c.coords_to_point(i,j)) for i,j in [[5, 0], [1, 0]]])
#         l4 = Line(*[Dot(ax_c.coords_to_point(i,j)) for i,j in [[1, 6], [5, 6]]])
#         self.play(MoveAlongPath(pb, l3), MoveAlongPath(pt, l4), rate_func=linear)
#         self.wait(1)
#         self.play(FadeOut(quad2, run_time=1), FadeOut(pb, run_time=1),FadeOut(pt, run_time=1))
# 
#         for dot in points:
#           self.play(Create(dot, run_time=0.1))
# 
#         self.wait(1)
#         self.play(FadeOut(*points))
#         self.wait(1)
#         self.play(FadeIn(top[2]), FadeIn(bottom[2]))
#         self.wait(2)
#         self.play(FadeIn(*[bottom[i].set(color=RED) for i in [0,1,3,4]]))
#         self.wait(1)
#         self.play(FadeOut(*[bottom[i] for i in [0,1,3,4]]))
#         self.wait(2)
# 
# 
#         self.play(FadeIn(left[2]), FadeIn(right[2]))
#         self.wait(2)
#         self.play(FadeIn(*[right[i].set(color=RED) for i in [0,1,3,4]]))
#         self.wait(1)
#         self.play(FadeOut(*[right[i] for i in [0,1,3,4]]))
#         self.wait(2)
# 
#         self.play(FadeOut(rect), FadeOut(ax_c), FadeOut(*[top[2], left[2], right[2], bottom[2]]), run_time=1)
# 
#         solution_text1 = Tex(r"$\frac{4}{5} \cdot \frac{4}{5} = \frac{16}{25}$")
#         solution_text2 = Tex(r"$1 - \frac{16}{25} = \frac{9}{25}$").next_to(solution_text1, DOWN)
# 
#         self.play(Write(solution_text1), Write(solution_text2), run_time=2)
# 
# 
#         self.wait(2)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh -v WARNING Test
# class Test(Scene):
#   def construct(self):
#         ax = Axes(
#             x_range=[0, 7, 1],
#             y_range=[0, 7, 1],
#             x_length = 5,
#             y_length = 5)
#         ax_c = ax.add_coordinates()
#         # a dot with respect to the axes
#         self.add(ax_c)
#         rect_points = [[0, 0], [0, 6], [6, 6], [6, 0]]
#         rect = Polygon(*[ax_c.coords_to_point(i, j) for i,j in rect_points])
#         self.play(Create(rect, run_time=1.5))
# 
# 
#         top = [Dot(ax_c.coords_to_point(i, 6)) for i in range(1,6)]
#         left = [Dot(ax_c.coords_to_point(0, i)) for i in range(1,6)]
#         right = [Dot(ax_c.coords_to_point(6, i)) for i in range(5,0,-1)]
#         bottom = [Dot(ax_c.coords_to_point(i, 0)) for i in range(5,0,-1)]
#         points = left+top+right+bottom
#         for dot in points:
#           self.play(Create(dot, run_time=0.1))
# 
#         self.wait(1)
#         self.play(FadeOut(*points))
#         self.wait(1)
#         self.play(FadeIn(top[2]), FadeIn(bottom[2]))
#         self.wait(2)
#         self.play(FadeIn(*[bottom[i].set(color=RED) for i in [0,1,3,4]]))
#         self.wait(1)
#         self.play(FadeOut(*[bottom[i] for i in [0,1,3,4]]))
#         self.wait(2)
# 
# 
#         self.play(FadeIn(left[2]), FadeIn(right[2]))
#         self.wait(2)
#         self.play(FadeIn(*[right[i].set(color=RED) for i in [0,1,3,4]]))
#         self.wait(1)
#         self.play(FadeOut(*[right[i] for i in [0,1,3,4]]))
#         self.wait(2)
# 
#         self.play(FadeOut(rect), FadeOut(ax_c), FadeOut(*[top[2], left[2], right[2], bottom[2]]), run_time=1)
# 
#         solution_text1 = Tex(r"$\frac{4}{5} \cdot \frac{4}{5} = \frac{16}{25}$")
#         solution_text2 = Tex(r"$1 - \frac{16}{25} = \frac{9}{25}$").next_to(solution_text1, DOWN)
# 
#         self.play(Write(solution_text1), Write(solution_text2), run_time=2)
#         self.wait(2)

"""The square with vertices (0,0), (6,0), (6,6), and (0.6) is drawn on the coordinate plane. Justin constructs a convex quadrilateral by selecting a non-corner lattice point uniformly at random from each side of the square as its vertices. If the probability that the area formed by the quadrilateral is exactly half the area of the square can be expressed as a reduced common fraction a/b, compute a+b."""